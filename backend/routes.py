# app.py
from __future__ import annotations

import base64
import hmac
import os
from datetime import UTC, datetime, timedelta
from hashlib import sha256
from typing import Annotated, Final

import jwt  # PyJWT
from argon2 import PasswordHasher
from fastapi import (
    Cookie,
    Depends,
    FastAPI,
    Header,
    HTTPException,
    Response,
    status,
)
from pydantic import BaseModel, EmailStr
from sqlalchemy import (
    Boolean,
    Index,
    LargeBinary,
    String,
    Text,
    create_engine,
    select,
)
from sqlalchemy import (
    text as sql_text,
)
from sqlalchemy.dialects.postgresql import INET, UUID
from sqlalchemy.orm import DeclarativeBase, Mapped, Session, mapped_column

# =============================================================================
# Configuration (kept close to production defaults)
# =============================================================================

DATABASE_URL: Final[str] = os.getenv(
    "DATABASE_URL",
    "postgresql+psycopg://postgres:postgres@localhost:5432/appdb",
)

# --- JWT signing ---
# Prefer asymmetric keys (RS256) like in prod. If keys are missing, fall back to HS256.
JWT_PRIVATE_KEY: Final[str | None] = os.getenv("JWT_PRIVATE_KEY")
JWT_PUBLIC_KEY: Final[str | None] = os.getenv("JWT_PUBLIC_KEY")
if JWT_PRIVATE_KEY and JWT_PUBLIC_KEY:
    JWT_ALG: Final = "RS256"
    _JWT_SIGNING_KEY: Final[str] = JWT_PRIVATE_KEY
    _JWT_VERIFYING_KEY: Final[str] = JWT_PUBLIC_KEY
else:
    JWT_ALG = "HS256"  # type: ignore[assignment]
    JWT_SECRET: Final[str] = os.getenv("JWT_SECRET", "dev-secret-change-me")
    _JWT_SIGNING_KEY = JWT_SECRET
    _JWT_VERIFYING_KEY = JWT_SECRET

ACCESS_TTL: Final[timedelta] = timedelta(minutes=15)  # short-lived access token
SESSION_TTL: Final[timedelta] = timedelta(days=60)  # long-lived session/refresh

# --- Refresh token hashing (DB stores only a derived value, not the secret) ---
REFRESH_HMAC_SECRET: Final[bytes] = os.getenv("REFRESH_HMAC_SECRET", "dev-rt-hmac").encode()

# --- Cookies (prod-like in dev) ---
REFRESH_COOKIE_NAME: Final[str] = "rt"  # refresh token cookie
CSRF_COOKIE_NAME: Final[str] = "csrf"  # non-HttpOnly CSRF token cookie (double-submit)
COOKIE_SECURE: Final[bool] = os.getenv("COOKIE_SECURE", "false").lower() == "true"
COOKIE_SAMESITE: Final[str] = os.getenv("COOKIE_SAMESITE", "strict")  # 'strict' | 'lax' | 'none'
COOKIE_DOMAIN: Final[str | None] = os.getenv("COOKIE_DOMAIN") or None
COOKIE_PATH: Final[str] = "/"

# =============================================================================
# SQLAlchemy setup (Declarative mapping for the two minimal tables)
# =============================================================================


class Base(DeclarativeBase):
    """Base class for SQLAlchemy declarative models."""


class User(Base):
    """ORM mapping of the `users` table.

    Fields:
      - id: UUID primary key (generated by the DB via gen_random_uuid()).
      - email: user email (DB uses CITEXT for case-insensitive uniqueness).
      - password_hash: PHC-formatted string from Argon2/bcrypt (algorithm+params+salt+hash).
      - created_at: timestamp in UTC (set by DB DEFAULT now()).

    Why store `password_hash` as text?
      - PHC strings are self-describing (algorithm + parameters + salt + hash),
        so `text` allows algorithm/parameter upgrades without schema changes.
    """

    __tablename__ = "users"

    id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True)
    email: Mapped[str] = mapped_column(String, unique=True, nullable=False)
    password_hash: Mapped[str] = mapped_column(Text, nullable=False)
    created_at: Mapped[datetime] = mapped_column(nullable=False)


class SessionRow(Base):
    """ORM mapping of the `sessions` table (server-side state for refresh tokens).

    Fields:
      - id: UUID for the session (the `sid` embedded in access JWTs).
      - user_id: owner (FK to users.id).
      - refresh_token_hash: HMAC-SHA256(plaintext_refresh, server_secret), stored as bytes.
      - created_at: when the session was created.
      - last_used_at: updated at refresh (telemetry/anomaly detection).
      - expires_at: session hard expiry (e.g., 60 days).
      - is_revoked: set true on logout/compromise; instantly kills the session.
      - ip, user_agent: optional for device management/forensics.

    Why store only a hash/HMAC, not the plaintext token?
      - A refresh token is a credential. Storing only a derived value means a DB leak
        does not immediately give an attacker refresh capability.
    """

    __tablename__ = "sessions"

    id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True)
    user_id: Mapped[str] = mapped_column(UUID(as_uuid=False), nullable=False, index=True)
    refresh_token_hash: Mapped[bytes] = mapped_column(LargeBinary, unique=True, nullable=False)
    created_at: Mapped[datetime] = mapped_column(nullable=False)
    last_used_at: Mapped[datetime | None]
    expires_at: Mapped[datetime] = mapped_column(nullable=False, index=True)
    is_revoked: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    ip: Mapped[str | None] = mapped_column(INET, nullable=True)
    user_agent: Mapped[str | None] = mapped_column(Text, nullable=True)


# Partial index used by the application to quickly filter active sessions
Index(
    "idx_sessions_active_exp",
    SessionRow.expires_at,
    postgresql_where=sql_text("is_revoked = false"),
)

# Engine: psycopg (v3) driver via SQLAlchemy 2.x style
engine = create_engine(DATABASE_URL, future=True, pool_pre_ping=True)


def get_db() -> Session:
    """FastAPI dependency that yields a SQLAlchemy Session.

    Why:
      - Keeps transaction boundaries per-request.
      - Ensures connections are returned to the pool even on exceptions.
    """
    with Session(engine) as session:
        yield session


# =============================================================================
# Cryptographic helpers (passwords, access JWTs, refresh tokens)
# =============================================================================

ph = PasswordHasher()
"""Argon2id password hasher:
   - Provides memory-hard hashing to resist GPU/ASIC cracking.
   - Stores PHC strings (algorithm, parameters, salt, hash) in `users.password_hash`."""


def now_utc() -> datetime:
    """Returns the current UTC time.

    Why:
      - Ensures consistent time arithmetic for token/session expiry and comparisons.
    """
    return datetime.now(UTC)


def mint_access_jwt(*, sub: str, sid: str) -> str:
    """Create a short-lived access JWT for the given user (sub) and session (sid).

    Data flow:
      - The `sid` binds this access token to a particular server-side session row.
      - On every protected request, we verify the JWT and check the `sid` row
        for revocation/expiry to enable instant logout.

    Returns:
      - A signed JWT string (RS256 if keys provided, else HS256).

    """
    payload = {
        "sub": sub,
        "sid": sid,
        "iat": int(now_utc().timestamp()),
        "exp": int((now_utc() + ACCESS_TTL).timestamp()),
    }
    return jwt.encode(payload, _JWT_SIGNING_KEY, algorithm=JWT_ALG)


def verify_access_jwt(token: str) -> dict:
    """Decode and verify an access JWT.

    Verifies:
      - Signature (RS256/HS256 depending on configuration).
      - Standard claims (`exp`, `iat` handled by PyJWT; `sub`, `sid` validated by caller).

    Returns:
      - The decoded claims dictionary (on success).

    Raises:
      - jwt.PyJWTError on signature/expiry/format problems.

    """
    return jwt.decode(token, _JWT_VERIFYING_KEY, algorithms=[JWT_ALG])


def gen_refresh_token() -> str:
    """Generate a high-entropy refresh token to send to the client (plaintext form).

    Format:
      - base64url string (no padding) encoding 32 random bytes (~43 chars).

    Why base64url:
      - URL/cookie safe without escaping; keeps the value compact.
    """
    raw = os.urandom(32)
    return base64.urlsafe_b64encode(raw).rstrip(b"=").decode()


def hmac_refresh(plaintext: str) -> bytes:
    """Compute the HMAC-SHA256 of a plaintext refresh token using a server-only secret.

    Why HMAC instead of plain hash:
      - If the DB is compromised, an attacker cannot validate guesses or reuse the
        derived value without the server-held secret. This keeps the “secret boundary”
        in the app, not in the DB.
    """
    return hmac.new(REFRESH_HMAC_SECRET, plaintext.encode(), sha256).digest()


def gen_csrf_token() -> str:
    """Generate a CSRF token (base64url) for double-submit protection.

    Data flow:
      - On login we set a non-HttpOnly CSRF cookie and the client must echo its value
        in the `X-CSRF-Token` header when calling /auth/refresh. Browsers auto-attach
        cookies cross-site; this header proves the request originated from your app.
    """
    return gen_refresh_token()


# =============================================================================
# Pydantic schemas (request/response)
# =============================================================================


class LoginIn(BaseModel):
    """Input payload for /auth/login.

    Fields:
      - email: user email (validated as EmailStr).
      - password: plaintext password (verified with Argon2id).
    """

    email: EmailStr
    password: str


class TokenOut(BaseModel):
    """Output model for endpoints that mint an access token.

    Fields:
      - access_token: short-lived JWT used in `Authorization: Bearer ...` header.
      - token_type: the scheme (always 'bearer').
      - csrf_token: returned on login for convenience (browser can store it),
                    also set as a non-HttpOnly cookie for double-submit protection.
    """

    access_token: str
    token_type: str = "bearer"
    csrf_token: str | None = None


# =============================================================================
# Authentication dependency
# =============================================================================


def require_session(
    db: Annotated[Session, Depends(get_db)],
    authorization: Annotated[str | None, Header(None)] = None,
) -> tuple[str, str]:
    """Validate the `Authorization: Bearer <access-jwt>` header and ensure the session is active.

    Steps:
      1) Extract and verify the JWT signature/expiry.
      2) Read `sub` (user id) and `sid` (session id) from claims.
      3) Look up the `sid` in the `sessions` table and ensure:
         - row exists,
         - not revoked,
         - `expires_at` is in the future.
      4) If all checks pass, return `(user_id, session_id)` tuple for downstream use.

    Why check the DB per request:
      - Enables **instant revocation** (logout/kill switch) even if an access token
        hasn't yet expired. This is the key benefit of the hybrid design.
    """
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")

    token = authorization.split(" ", 1)[1]
    try:
        payload = verify_access_jwt(token)
    except jwt.PyJWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")

    sub = payload.get("sub")
    sid = payload.get("sid")
    if not sub or not sid:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token claims")

    row = db.get(SessionRow, sid)
    if row is None or row.is_revoked or row.expires_at <= now_utc():
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Session expired or revoked",
        )

    return sub, sid


# =============================================================================
# FastAPI application and routes
# =============================================================================

app = FastAPI(title="Minimal Hybrid Auth (FastAPI 0.118, Py3.13, Postgres 18)")


@app.post("/auth/login", response_model=TokenOut)
def login(
    data: LoginIn,
    response: Response,
    db: Annotated[Session, Depends(get_db)],
    user_agent: Annotated[str | None, Header(None, alias="User-Agent")] = None,
):
    """Authenticate a user, create a session (refresh), and return an access token.

    Data flow:
      - Client submits email/password.
      - Server verifies password (Argon2id).
      - Server generates a **refresh token (plaintext)**, stores only its **HMAC** in DB,
        and sets the plaintext in an **HttpOnly cookie**.
      - Server mints a **short-lived access JWT** that embeds `sid` (session id).
      - For browser flows, server also sets a **CSRF cookie** (non-HttpOnly) for /auth/refresh.

    Returns:
      - JSON with `access_token` and a convenience `csrf_token` value.
      - Cookies: `rt` (HttpOnly refresh token), `csrf` (non-HttpOnly).

    Security:
      - HttpOnly refresh cookie prevents JS exfiltration.
      - CSRF double-submit token is required for /auth/refresh to stop CSRF attacks.

    """
    # 1) Find user
    user = db.execute(select(User).where(User.email == data.email)).scalar_one_or_none()
    if user is None:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")

    # 2) Verify password
    try:
        ph.verify(user.password_hash, data.password)
    except Exception:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")

    # 3) Create a session row with a fresh refresh token
    refresh_plain = gen_refresh_token()
    refresh_hash = hmac_refresh(refresh_plain)

    # Generate a new session id from the DB to match server-side defaults
    sid = db.execute(sql_text("SELECT gen_random_uuid()")).scalar_one()

    row = SessionRow(
        id=sid,
        user_id=user.id,
        refresh_token_hash=refresh_hash,
        created_at=now_utc(),
        last_used_at=None,
        expires_at=now_utc() + SESSION_TTL,
        is_revoked=False,
        ip=None,  # you can fill from X-Forwarded-For if trusted
        user_agent=user_agent,
    )
    db.add(row)
    db.commit()

    # 4) Issue the short-lived access token
    access = mint_access_jwt(sub=user.id, sid=row.id)

    # 5) Set refresh cookie (HttpOnly) and CSRF cookie (non-HttpOnly)
    response.set_cookie(
        key=REFRESH_COOKIE_NAME,
        value=refresh_plain,
        httponly=True,
        secure=COOKIE_SECURE,
        samesite=COOKIE_SAMESITE,
        domain=COOKIE_DOMAIN,
        path=COOKIE_PATH,
        max_age=int(SESSION_TTL.total_seconds()),
    )

    csrf_token = gen_csrf_token()
    response.set_cookie(
        key=CSRF_COOKIE_NAME,
        value=csrf_token,
        httponly=False,  # must be readable by client to echo in header
        secure=COOKIE_SECURE,
        samesite=COOKIE_SAMESITE,
        domain=COOKIE_DOMAIN,
        path=COOKIE_PATH,
        max_age=int(SESSION_TTL.total_seconds()),
    )

    return TokenOut(access_token=access, csrf_token=csrf_token)


@app.post("/auth/refresh", response_model=TokenOut)
def refresh_token(
    response: Response,
    db: Annotated[Session, Depends(get_db)],
    rt_cookie: Annotated[str | None, Cookie(alias=REFRESH_COOKIE_NAME)] = None,
    csrf_cookie: Annotated[str | None, Cookie(alias=CSRF_COOKIE_NAME)] = None,
    csrf_header: Annotated[str | None, Header(None, alias="X-CSRF-Token")] = None,
    user_agent: Annotated[str | None, Header(None, alias="User-Agent")] = None,
):
    """Rotate the refresh token and mint a new access token.

    Data flow (browser):
      - Browser automatically sends the HttpOnly `rt` cookie.
      - Client JS must also send `X-CSRF-Token` header equal to the non-HttpOnly `csrf` cookie.
      - Server verifies CSRF (double-submit).
      - Server looks up the session by HMAC(refresh_plain) and ensures it is active.
      - Server **rotates** the refresh token (new plaintext to client, new HMAC in DB),
        updates `last_used_at`, and mints a fresh access token bound to the same `sid`.

    Returns:
      - JSON with new `access_token`.
      - New `rt` cookie; `csrf` cookie preserved.

    Why rotation:
      - Detects token theft (old token reuse) and reduces the window of compromise.

    """
    # 0) CSRF check for browser flows (dev mirrors prod)
    if not (csrf_cookie and csrf_header and csrf_cookie == csrf_header):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="CSRF validation failed",
        )

    # 1) Must have a refresh cookie
    if not rt_cookie:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Missing refresh token",
        )

    # 2) Find session by HMAC(refresh)
    rth = hmac_refresh(rt_cookie)
    row = db.execute(
        select(SessionRow).where(SessionRow.refresh_token_hash == rth),
    ).scalar_one_or_none()
    if row is None or row.is_revoked or row.expires_at <= now_utc():
        # Here you could implement "reuse detection" policy (revoke all, alert, etc).
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid or expired session",
        )

    # 3) Rotate refresh and update telemetry
    new_plain = gen_refresh_token()
    row.refresh_token_hash = hmac_refresh(new_plain)
    row.last_used_at = now_utc()
    if user_agent:
        row.user_agent = user_agent
    db.commit()

    # 4) Mint a new short-lived access token tied to the same sid
    access = mint_access_jwt(sub=row.user_id, sid=row.id)

    # 5) Set new refresh cookie; keep CSRF cookie as-is
    response.set_cookie(
        key=REFRESH_COOKIE_NAME,
        value=new_plain,
        httponly=True,
        secure=COOKIE_SECURE,
        samesite=COOKIE_SAMESITE,
        domain=COOKIE_DOMAIN,
        path=COOKIE_PATH,
        max_age=int((row.expires_at - now_utc()).total_seconds()),
    )

    return TokenOut(access_token=access)


@app.post("/auth/logout", status_code=status.HTTP_204_NO_CONTENT)
def logout(
    response: Response,
    db: Annotated[Session, Depends(get_db)],
    rt_cookie: Annotated[str | None, Cookie(alias=REFRESH_COOKIE_NAME)] = None,
):
    """Log out the current device/session.

    Data flow:
      - Client sends the refresh cookie automatically (if present).
      - Server looks up the session by HMAC(refresh) and sets `is_revoked = true`.
      - Server clears the refresh cookie client-side.

    Effect:
      - All access tokens carrying this session's `sid` will be denied immediately
        because protected routes re-check the session row per request.
    """
    if rt_cookie:
        rth = hmac_refresh(rt_cookie)
        row = db.execute(
            select(SessionRow).where(SessionRow.refresh_token_hash == rth),
        ).scalar_one_or_none()
        if row is not None and not row.is_revoked:
            row.is_revoked = True
            db.commit()

    # Clear refresh + csrf cookies (idempotent)
    response.delete_cookie(key=REFRESH_COOKIE_NAME, domain=COOKIE_DOMAIN, path=COOKIE_PATH)
    response.delete_cookie(key=CSRF_COOKIE_NAME, domain=COOKIE_DOMAIN, path=COOKIE_PATH)
    return Response(status_code=status.HTTP_204_NO_CONTENT)


@app.get("/check")
def check(_auth: Annotated[tuple[str, str], Depends(require_session)]):
    """Minimal protected endpoint.

    Behavior:
      - If the `require_session` dependency succeeds → returns 200 and a success payload.
      - If not authenticated (no/invalid JWT, revoked/expired session) → the dependency
        raises 401 and the handler is never executed.
    """
    return {"status": "success"}
